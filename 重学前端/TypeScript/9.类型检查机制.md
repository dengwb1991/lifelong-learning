# 类型检查机制

定义：TypeScript 编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为。

作用：辅助开发，提高开发效率

* 类型推断
* 类型兼容性
* 类型保护

## 类型推断

定义：不需要指定变化的类型（函数的返回值类型），TypeScript 可以根据某些规则自动为其推断出一个类型。

* 基础类型推断
* 最佳通用类型推断
* 上下文类型推断

### 基础类型推断

基本类型推断经常出现在初始化变量的时候。

```ts
let a
// let a: any

let a = 1
// let a: number

let a = []
// let a: any[]
```

声明变量 `a` 时，我们不指定它的类型，`ts` 就会默认推断出它是 `any` 类型。

如果我们将它复制为 `1`，`ts` 就会推断出它是 `number` 类型。

如果我们将它复制为 `[]`，`ts` 就会推断出它是 `any` 类型的数组。

基本类型推断还会出现在定义函数参数。

```ts
let a = (x = 1) => {}
// let a: (x?: number) => void
```

声明函数 `a`，设置一个参数 `x`，为它赋值一个默认参数 `1`，此时 `ts` 就会推断出它是 `number` 类型。同样返回值类型也会被推断。

### 最佳通用类型推断

当需要从多个类型中推断出一个类型时，`ts` 就会尽可能的推断出一个最佳通用类型

```ts
let a = [1, null]
// let a: (number | null)[]
```

声明一个变量 `a`，值为一个包含数字 `1` 和 `null` 的数组。此时，变量 `a` 就被推断为 `number` 和 `null` 的联合类型。

以上的类型推断都是从右向左的推断，根据表达式的值推断出变量的类型。还有一种方式是从左到右，根据上下文推断。

### 上下文类型推断

通常发生在事件处理中。

```ts
window.onkeydown = (event) => {
}
// (parameter) event: KeyboardEvent
```

为 `window` 绑定 `onkeydown` 事件，参数为 `event`，此时 `ts` 会根据左侧的事件绑定推断出右侧事件的类型。

## 类型兼容性

什么是类型兼容性？

当一个类型 Y 可以赋值给另一个类型 X 时，我们可以认为类型 X 兼容类型 Y。

X 兼容 Y : X (目标类型) = Y (源类型)

### 变量兼容性

```ts
let s: string = 'abc'
s = null
```

默认会提示 Type 'null' is not assignable to type 'string'. 如果将 `tsconfig.json` 内的 `strictNullChecks` 的值设置为 `false`，这时编译就不会报错。

可以说明 `string` 类型兼容 `null` 类型，`null` 是 `string` 类型的子类型。

### 接口兼容性

```ts
interface X {
  a: any
  b: any
}

interface Y {
  a: any
  b: any
  c: any
}

let x: X = { a: 1, b: 2 }
let y: Y = { a: 1, b: 2, c: 3 }

x = y
y = x
// Property 'c' is missing in type 'X' but required in type 'Y'.ts(2741)
// index.ts(9, 3): 'c' is declared here.
```

`y` 可以赋值给 `x`，`x` 不可以赋值给 `y`。接口之间相互赋值时，成员少的会兼容成员多的。源类型必须具备目标类型的必要属性。

### 函数兼容性

```ts
type Handler = (a: number, b: number) => void
function hof(handler: Handler) {
  return handler
}

// 参数个数
let handler1 = (a: number) => {}
hof(handler1)

let handler2 = (a: number, b: number, c: number) => {}
hof(handler2)
// Argument of type '(a: number, b: number, c: number) => void' is not assignable to parameter of type 'Handler'.

// 参数类型
let handler3 = (a: string) => {}
hof(handler3)
// Types of parameters 'a' and 'a' are incompatible. Type 'number' is not assignable to type 'string'.
```

函数参数个数，参数多的兼容参数少的。目标类型 `handler` 有两个参数，定义只有一个参数的函数 `handler1`，将 `handler1` 传入 `hof` 方法作为参数(PASS)。定义有三个参数的函数 `handler2`，同样作为参数传入 `hof` 方法(FAIL)。

函数参数类型变更(FAIL)。

```ts
// 固定参数
let a = (p1: number, p2: number) => {}
// 可选参数
let b = (p1?: number, p2?: number) => {}
// 剩余参数
let c = (...args: number[]) => {}

a = b
a = c
b = a // FAIL
b = c // FAIL
c = a
c = b
```

固定参数兼容可选参数和剩余参数。可选参数不兼容固定参数和剩余参数，如果将 `tsconfig.json` 内的 `strictFunctionTypes` 的值设置为 `false`，这时编译就不会报错。剩余参数兼容固定参数和可选参数。

```ts
// 复杂类型
interface Point3D {
  x: number
  y: number
  z: number
}

interface Point2D {
  x: number
  y: number
}
let p3d = (point: Point3D) => {}
let p2d = (point: Point2D) => {}

p3d = p2d
p2d = p3d
// Property 'z' is missing in type 'Point2D' but required in type 'Point3D'.
```

成员个数多的兼容成员个数少的，这里与接口兼容性结论相反。可以把对象拆分为参数，参数多的兼容参数少的，与函数兼容性结论一致。

如果想要 p2d = p3d 兼容。将 `tsconfig.json` 内的 `strictFunctionTypes` 的值设置为 `false`。

```ts
// 返回值类型
let f = () => ({ name: 'Alice' })
let g = () => ({ name: 'Alice', location: 'Beijing' })
f = g
g = f // FAIL
```

目标函数的返回值类型，必须与源函数的返回值类型相同，或为其子类型。成员少的兼容成员多的。

```ts
// 函数重载
function overload (a: number, b: number): number
function overload (a: string, b: string): string
function overload (a: any, b: any): any {}
```

函数重载分为两个部分，第一个部分为函数重载的列表，也就是第一、二个 `overload` 函数，也就是目标函数。第二个部分就是函数的具体实现，也就是第三个 `overload` 函数，也就是源函数。在重载列表中，目标函数的参数要大于等于源函数的参数。


### 枚举兼容性

```ts
// 枚举

enum Fruit { Apple, Banana }
enum Color { Red, Yellow }

let fruit: Fruit.Apple = 3
let no: number = Fruit.Apple

let color: Color.Red = Fruit.Apple // FAIL
```

枚举类型和数值(number)类型相互兼容，枚举与枚举之间相互不兼容

### 类兼容性

```ts
class A {
  constructor (p: number, q: number) {}
  id: number = 1
}

class B {
  static s = 1
  constructor (p: number) {}
  id: number = 2
}

let aa = new A(1, 2)
let bb = new B(1)

aa = bb
bb = aa
```

比较类与类是否兼容时，静态成员和构造函数不进行比较。成员少的兼容成员多的，父类与子类的实例相互兼容。

### 泛型兼容性

```ts
interface Empty<T> {}

let obj1: Empty<number> = {}
let obj2: Empty<String> = {}

obj1 = obj2

// 泛型函数

let log1 = <T>(x: T): T => {
  console.log('x')
  return x
}
let log2 = <U>(y: U): U => {
  console.log('y')
  return y
}

log1 = log2
```

泛型接口未设置任何属性时，`obj1` 与 `obj2` 相互兼容，若此时 `Empty` 设置了属性 `value: T` 时，`obj1` 与 `obj2` 不兼容。

泛型函数参数类型相同，参数多的兼容参数少的。

## 总结

结构之间兼容，成员少的兼容成员多的
函数之间兼容，参数多的兼容参数少的