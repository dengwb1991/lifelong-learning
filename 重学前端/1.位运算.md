# 位运算符

**按位运算符**将其操作数视为**32位**（0和1）的序列，而不是十进制，十六进制或八进制数。例如，十进制**数字9** 具有1001的二进制表示。按位操作符操作数字的二进制形式，但返回值依然是标准的JavaScript数值。

# 七种运算方式

下面的表格总结了JavaScript中的按位操作符

| 运算符 | 用法 | 描述 | 
| --- | --- | --- |
| 与（&）| a & b | 当两个操作数相对应的位都为1时，结果才为1，否则为0。 |
| 或（\|）| a \| b | 当两个操作数相对应的位至少有一个为1时，结果为1，否则为0。 |
| 异或（^） | a ^ b | 当两个操作数相对应的位只有一个为1时，结果为1，否则为0。 |
| 取反（~）| ~ a |  反转操作数的位，即0变成1，1变成0。|
| 左移（<<）| a << b | 将 a 的二进制形式向左移 b (< 32) 位，右边用0填充。 |
| 右移（>>）| a >> b | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。 |
| 零填充右移（>>>）| a >>> b | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 |


在讲位运算之前，先简要讲述一下机器数的形式**原码、反码、补码**，

### 什么是机器数？

机器数是将符号"数字化"的数，是数字在计算机中的二进制表示形式。在通常的运算中，用“+”、“-”表示正数和负数，而数字电路不识别“+”，“-”。因此，在数字电路中把一个数的最高位作为符号位，并用0表示“+”，用1表示“-”。

### 原码

首位为符号位，0表示整数，1表示负数，其余位表示数值。

例如**0**000 0011表示+3，而**1**000  0011表示-3。

问题来了，在原码中（+3）+（-3） = 0 吗？0000 0011 + 1000 0011 = 1000 0110 为-6的错误结果，显然这个结果并不是我们想要的。如果解决原码中正负相加的问题呢？**反码**

### 反码

如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反。

例如 -3原码为 **1**000 0011，反码为**1**111 1100




# 原码、反码、补码

## 原码

# 二进制32位

所有位运算符的操作数都以二进制补码格式转换为带符号的32位整数。二进制补码格式意味着数字的负对应（例如5对-5）是所有数字的位被反转（按位数而不是数字）加1。

例如，以下对整数314进行编码：

```js
0000 0000 0000 0000 0000 0001 0011 1010
```

# 进制

```
//将26进制转10进制
var ConvertNum = function (str) {
    var n = 0;
    var s = str.match(/./g);//求出字符数组
    var j = 0;
    for (var i = str.length - 1, j = 1; i >= 0; i--, j *= 26) {
        var c = s[i].toUpperCase();
        if (c < 'A' || c > 'Z') {
            return 0;
        }
        n += (c.charCodeAt(0) - 64) * j;
    }
    return n;
}
//测试
var teststr = "AB";
alert(ConvertNum(teststr));
//将10进制转26进制
var Convert26=function(num){
    var str="";
    while (num > 0){
        var m = num % 26;
        if (m == 0){
            m = 26;
        }
        str = String.fromCharCode(m + 64) + str;
        num = (num - m) / 26;
    }
    return str;
}

//测试
var num = 28;
alert(Convert26(num));
```