# 位运算符

**按位运算符**将其操作数视为**32位**（0和1）的序列，而不是十进制，十六进制或八进制数。例如，十进制**数字9** 具有1001的二进制表示。按位操作符操作数字的二进制形式，但返回值依然是标准的JavaScript数值。

# 七种运算方式

下面的表格总结了JavaScript中的按位操作符

| 运算符 | 用法 | 描述 | 
| --- | --- | --- |
| 与（&）| a & b | 当两个操作数相对应的位都为1时，结果才为1，否则为0。 |
| 或（\|）| a \| b | 当两个操作数相对应的位至少有一个为1时，结果为1，否则为0。 |
| 异或（^） | a ^ b | 当两个操作数相对应的位只有一个为1时，结果为1，否则为0。 |
| 取反（~）| ~ a |  反转操作数的位，即0变成1，1变成0。|
| 左移（<<）| a << b | 将 a 的二进制形式向左移 b (< 32) 位，右边用0填充。 |
| 右移（>>）| a >> b | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。 |
| 零填充右移（>>>）| a >>> b | 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。 |


在讲位运算之前，先简要讲述一下机器数的形式**原码、反码、补码**，

### 什么是机器数？

机器数是将符号"数字化"的数，是数字在计算机中的二进制表示形式。在通常的运算中，用“+”、“-”表示正数和负数，而数字电路不识别“+”，“-”。因此，在数字电路中把一个数的最高位作为符号位，并用0表示“+”，用1表示“-”。

### 原码

首位为符号位，0表示整数，1表示负数，其余位表示数值。

例如**0**000 0011表示+3，而**1**000  0011表示-3。

* 原码中0有两种表现形式，中+0为 **0**000 0000，-0为 **1** 000 0000

问题来了，在原码中（+3）+（-3） = 0 吗？0000 0011 + 1000 0011 = 1000 0110 为-6的错误结果，显然这个结果并不是我们想要的。如果解决原码中正负相加的问题呢？**反码**

### 反码

如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反。

例如 -3原码为 **1**000 0011，反码为**1**111 1100

0000 0011 + 1111 1100 = 1111 1111 为-0，解决上面原码遇到的问题，但是新问题来了，反码中0依然有两种表现方式，0000 0000（+0）和 1111 1111（-0）。这时出现了**补码**

### 补码

如果是正数，则表示方法和原码一样；如果是负数，则将数字的反码未位加1(相当于将原码数值位取反后未位加1)

例如 -3反码为**1**111 1100，其补码为**1**111 1101

0000 0011 + 1111 1101 = 0000 0000（+0）

重述一遍，补码保证了当一个数是正数时，其最左的bit位是0，当一个数是负数时，其最左的bit位是1。因此，最左边的bit位被称为符号位。

#### 为什么会有原码，反码，补码？

计算机采用二进制表示数，那么具体如何表示其中也是有学问的。原码是人类最直观想到的表现方式，但原码有缺点，于是产生了反码，反码也有缺点，最后产生了相对合理补码，于是计算机系统大多使用补码来存储二进制数。反码的作用主要是方便原码到补码的过渡，方便理解。
如果只有加法和正数，那么使用原码没有什么问题。之所以出现反码、补码，正是为了解决负数和减法所带来的问题。所以正数的原码、反码、补码都是一样的。

如果想对原码、反码、补码有更深的了解，推荐读《计算机原理》这本书，这里就不再赘述了。

接下来重新讲回到位运算。

## 有符号32位整数

0 是所有bit数字0组成的整数。
```
// 十进制 = 二进制

0 = 0000 0000 0000 0000 0000 0000 0000 0000
```

-1 是所有bit数字1组成的整数。
```
-1 = 1111 1111 1111 1111 1111 1111 1111 1111
```

-2147483648（十六进制形式：-0x80000000）是除了最左边为1以外，其他bit位都为0的整数。
```
-2147483648 = 1000 0000 0000 0000 0000 0000 0000 0000
```

2147483647（十六进制形式：0x7fffffff）是除了最左边为0以外，其他bit位都为1的整数。
```
2147483647 = 0111 1111 1111 1111 1111 1111 1111 1111
```

* 所以 **数字-2147483648 和 2147483647 是32位有符号数字所能表示的最小和最大整数。**

下面讲一下位运算符

## & (按位与)

当两个操作数相对应的位都为1时，结果才为1，否则为0。

举个例子，7 & 4 （默认例子按照8bit展示）

```
7 = 0000 0111 
4 = 0000 0100

-------------

7 & 4 = 0000 0100  => 4
```

再举一个例子，7 & -4（关于负数在上面机器数中有介绍）

```
7 = 0000 0111 
-4 = 1111 1100

-------------

7 & -4 = 0000 0100 => 4
```

## | (按位或)

当两个操作数相对应的位至少有一个为1时，结果为1，否则为0。

举个例子，7 | 4

```
7 = 0000 0111 
4 = 0000 0100

-------------

7 | 4 = 0000 0111  => 7
```

## ^ (按位异或)

当两个操作数相对应的位只有一个为1时，结果为1，否则为0。

举个例子，7 ^ 4

```
7 = 0000 0111 
4 = 0000 0100

-------------

7 ^ 4 = 0000 0011  => 3
```

## ~ (按位非)

反转操作数的位，即0变成1，1变成0。

举个例子，~ 3

```
3 = 0000 0011 

-------------

~ 3 = 1111 1100  => -4

```

* ~ 小技巧

>> 根据 ~ 运算符，~ -1 为0，一下代码可以进行优化

```js
const arr = ['a', 'b', 'c']

// if (arr.indexOf('d') > -1) {
if (~arr.indexOf('d')) // 这里也可以用includes代替
   // 存在
} else {
   // 不存在
}
```

>> ~~取整

```
const num = 3.14

~~num // 3 原理根据位运算基于整数进行计算
```

## << (左移)

将 a 的二进制形式向左移 b 位，右边用0填充。

举个例子，7 << 2

```
7 = 0000 0111 

-------------

7 << 2 = 0001 1100  => 28
```

## >> (右移)

 将 a 的二进制表示向右移 b 位，丢弃被移出的位。

举个例子，7 >> 2

```
7 = 0000 0111 

-------------

7 >> 2 = 0000 0001  => 1
```

-7 >> 2（32bit）

```

-7 = 1111 1111 1111 1111 1111 1111 1111 1001

-------------

-7 >> 2 = 1111 1111 1111 1111 1111 1111 1111 1110 => -2

```

### >>>（零填充右移）

将 a 的二进制表示向右移 b  位，丢弃被移出的位，并使用 0 在左侧填充。

举个例子，7 >>> 2

```
7 = 0000 0111 

-------------

7 >>> 2 = 0000 0001  => 1
```

* -7 >>> 2 （与 >> 的区别） 

```
-7 = 1111 1111 1111 1111 1111 1111 1111 1001

-------------

-7 >>> 2 = 0011 1111 1111 1111 1111 1111 1111 1110  => 1073741822
```


几种运算方式到这里就简单的讲完了，我们结合原理来做几道面试题。

# 常见进制以及位运算面试题

## 二进制中1的个数

问题：请实现一个函数，输入一个整数，输出该二进制表示中1的个数。例如把9表示为二进制是1001，有2位是1。因此输入9时，该函数返回2。

解法1：右移
```js
function method (n) {
  var count = 0
  while (n) {
     if (n & 1) count++

     n = n >> 1
  }
  return count
}
```
该方法有一个重大的缺陷，当n为负数时，将会陷入无限循环。原因是位移前为负数，位移后仍然要保持为负数，因此位移后最高位会是1。假如一直向右位移，最终数字永远为-1。如何修复这个缺陷呢？这里我给出一个**非官方解法2**

解法2：零填充右移
```js
function method (n) {
  var count = 0
  while (n) {
     if (n & 1) count++

     n = n >>> 1
  }
  return count
}
```
乍一看没啥区别，我只是把右移换成了零填充右移。细心的同学已经猜到了，上面我有说位移要保持正负值不变，因此负数的最高位会是1，这一点导致了无限循环。那么我们把最高位1换成0不就可以了么！零填充右移（>>>）恰恰满足了需求。

解法3：左移
```js
function method (n) {
  var count = 0
  var flag = 1
  while (flag) {
    if (n & flag) count++
    flag = flag << 1
  }
  return count
}
```
flag值不断地左移与n值做与操作，大于0表示为1，反之为0。这个解法存在一个缺陷，就是循环的次数等于整数二进制的位数，32位整数需要循环32次。

解法4：减1与
```js
function method (n) {
  var count = 0
  while (n) {
    ++count
    n = (n - 1) & n
  }
  return count
}
```
该方法循环次数与二进制1的个数相等。

```
//将26进制转10进制
var ConvertNum = function (str) {
    var n = 0;
    var s = str.match(/./g);//求出字符数组
    var j = 0;
    for (var i = str.length - 1, j = 1; i >= 0; i--, j *= 26) {
        var c = s[i].toUpperCase();
        if (c < 'A' || c > 'Z') {
            return 0;
        }
        n += (c.charCodeAt(0) - 64) * j;
    }
    return n;
}
//测试
var teststr = "AB";
alert(ConvertNum(teststr));
//将10进制转26进制
var Convert26=function(num){
    var str="";
    while (num > 0){
        var m = num % 26;
        if (m == 0){
            m = 26;
        }
        str = String.fromCharCode(m + 64) + str;
        num = (num - m) / 26;
    }
    return str;
}

//测试
var num = 28;
alert(Convert26(num));
```



http://www.ruanyifeng.com/blog/2009/08/twos_complement.html

https://blog.51cto.com/weijiancheng/2097083